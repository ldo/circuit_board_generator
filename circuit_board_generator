#!/usr/bin/python3
#+
# Generate random patterns that look like printed-circuit
# board traces. Based on the JavaScript code found at
# <https://codepen.io/tsuhre/details/xgmEPe>.
#-

import sys
import math
import random
import qahirah as qah
from qahirah import \
    CAIRO, \
    Colour, \
    Vector

cell_size = 30
pattern_size = Vector(20, 20) # in units of cells
wire_length = 20
min_wire_length = 2
straightness = 5
dpi = qah.base_dpi
colours = \
    {
        "background" : Colour.from_hsva((1 / 3, 0.7, 0.3)),
        "pad" : Colour.grey(0),
        "trace" : Colour.from_hsva((0.25, 0.6, 0.6)),
    }

directions = tuple \
  (
    Vector(*v)
    for v in
        [
            (-1, -1), (0, -1), (1, -1),
            (1, 0),
            (1, 1), (0, 1), (-1, 1),
            (-1, 0),
        ] # following order in original code, but probably not important
  )

class Cell :

    def __init__(self, pos) :
        self.pos = pos
        self.available = True
    #end __init__

#end Cell

class Grid :

    def __init__(self) :
        self.cells = list \
          (
            Cell(Vector(i, j))
            for i in range(pattern_size.y)
            for j in range(pattern_size.x)
          )
    #end __init__

    def __getitem__(self, index) :
        index = Vector.from_tuple(index)
        assert valid_grid_pos(index)
        i, j = index
        return \
            self.cells[i * pattern_size.x + j]
    #end __getitem__

#end Grid

grid = Grid()

def valid_grid_pos(pos) :
    "is pos the coordinates of a valid position within the grid."
    return \
        (
            pos.isint()
        and
            pos.x >= 0 and pos.x < pattern_size.x
        and
            pos.y >= 0 and pos.y < pattern_size.y
        )
#end valid_grid_pos

def find_open_direction(pos) :
    "finds a random free direction that the wire can start from."
    check_directions = list(range(8))
    random.shuffle(check_directions)
    while True :
        if len(check_directions) == 0 :
            result = 0 # ?
            break
        #end if
        index = check_directions.pop()
        new_pos = pos + directions[index]
        if valid_grid_pos(new_pos) and grid[new_pos].available :
            result = index
            break
        #end if
    #end while
    return \
        result
#end find_open_direction

def no_crossover(dirindex, pos) :
    if dirindex % 2 == 0 :
        # diagonal step
        adj = directions[dirindex]
        result = grid[pos.x - adj.x, pos.x].available or grid[pos.x, pos.y - adj.y].available
    else :
        result = True
    #end if
    return \
        result
#end no_crossover

class Wire :

    def __init__(self, start) :
        self.cells = [start]
        start.available = False
        self.last_direction = find_open_direction(start.pos)
    #end __init__

    def __len__(self) :
        "the length of the wire, in cells."
        return \
            len(self.cells)
    #end __len__

    def render(self, ctx) :
        "draws the Wire into a graphics context."
        ctx.save()
        ctx.source_colour = colours["trace"]
        ctx.line_width = cell_size / 4
        ctx.new_path()
        for cell in self.cells :
            ctx.line_to(cell.pos * cell_size)
        #end for
        ctx.stroke()
        ctx.line_width = cell_size / 6
        for cell in (self.cells[0], self.cells[-1]) :
            ctx.new_sub_path()
            ctx.circle((cell.pos + Vector(0.5, 0.5)) * cell_size, cell_size * 0.7)
        #end for
        ctx.stroke_preserve()
        ctx.source_colour = colours["pad"]
        ctx.fill()
        ctx.restore()
    #end render

    def generate(self) :
        while True :
            if len(self.cells) == wire_length :
                break
            prev_cell = self.cells[-1]
            tries = random.choice(([0, 1, 1], [0, -1, 1]))
            has_space = False
            while True :
                if len(tries) == 0 :
                    break
                mod = tries.pop(math.floor(random.random() ** straightness * len(tries)))
                index = (self.last_direction + 4 + mod) % 8
                direction = directions[index]
                pos = prev_cell.pos + direction
                if valid_grid_pos(pos) :
                    cell = grid[pos]
                    if cell.available and no_crossover(index, pos) :
                        self.cells.append(cell)
                        cell.available = False
                        has_space = True
                        self.last_direction = (self.last_direction + mod) % 8
                        break
                    #end if
                #end if
            #end while
            if not has_space :
                break
        #end while
    #end generate

#end Wire

random.seed(10)
  # repeatable patterns for testing, for now

wires = []
positions_avail = list \
  (
    grid[i, j].pos
    for j in range(pattern_size.x)
    for i in range(pattern_size.y)
  )
while len(positions_avail) != 0 :
    # sys.stderr.write("positions_avail left = %s\n" % repr(positions_avail)) # debug
    pos = random.choice(positions_avail)
    cell = Cell(pos)
    wire = Wire(cell)
    wire.generate()
    sys.stderr.write("generated wire: %s\n" % repr(list(x.pos for x in wire.cells))) # debug
    wires.append(wire)
    for cell in wire.cells :
        try :
            positions_avail.remove(cell.pos)
        except ValueError :
            sys.stderr.write("dupl pos %s??\n" % repr(cell.pos)) # debug
        #end try
    #end for
#end while

pix = qah.ImageSurface.create \
  (
    format = CAIRO.FORMAT_RGB24,
    dimensions = round(pattern_size * cell_size * dpi / qah.base_dpi)
  )
ctx = \
    (qah.Context.create(pix)
        .scale(dpi / qah.base_dpi)
    )
ctx.source_colour = colours["background"]
ctx.paint()
for wire in wires :
    if len(wire) >= min_wire_length :
        wire.render(ctx)
    #end if
#end for

pix.flush().write_to_png("test.png")
