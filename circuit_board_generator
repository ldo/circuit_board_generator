#!/usr/bin/python3
#+
# Generate random patterns that look like printed-circuit
# board traces. Based on the JavaScript code found at
# <https://codepen.io/tsuhre/details/xgmEPe>.
#-

import sys
import os
import math
import random
import subprocess
import getopt
import qahirah as qah
from qahirah import \
    CAIRO, \
    Colour, \
    Vector

#+
# Useful stuff
#-

def pos_int(s) :
    i = int(s)
    if i <= 0 :
        raise ValueError("must be positive integer: %s" % repr(s))
    #end if
    return \
        i
#end pos_int

def vector_str(s, conv) :
    if ":" in s :
        result = Vector(*tuple(conv(v) for v in s.split(":", 1)))
    else :
        result = Vector(1, 1) * conv(s)
    #end if
    return \
        result
#end vector_str

#+
# Generating the circuit board
#-

cell_size = 30
pattern_size = Vector(20, 20) # in units of cells
margin = Vector(0, 0)
wire_length = 20
min_wire_length = 2
straightness = 5
dpi = qah.base_dpi
colours = \
    {
        "background" : Colour.from_hsva((1 / 3, 0.7, 0.3)),
        "pad" : Colour.grey(0),
        "trace" : Colour.from_hsva((1 / 8, 0.6, 0.6)),
    }

directions = tuple \
  (
    Vector(*v)
    for v in
        [
            (-1, -1), (0, -1), (1, -1),
            (1, 0),
            (1, 1), (0, 1), (-1, 1),
            (-1, 0),
        ]
          # all the different one-step directions from the
          # current cell, arranged in a circle.
  )

class Cell :

    def __init__(self, pos) :
        self.pos = pos
        self.available = True
    #end __init__

#end Cell

class Grid :

    def __init__(self) :
        self.cells = list \
          (
            Cell(Vector(j, i))
            for i in range(pattern_size.y)
            for j in range(pattern_size.x)
          )
    #end __init__

    def __getitem__(self, index) :
        index = Vector.from_tuple(index)
        assert valid_grid_pos(index)
        j, i = index
        return \
            self.cells[i * pattern_size.x + j]
    #end __getitem__

#end Grid

def valid_grid_pos(pos) :
    "is pos the coordinates of a valid position within the grid."
    return \
        (
            pos.isint()
        and
            pos.x >= 0 and pos.x < pattern_size.x
        and
            pos.y >= 0 and pos.y < pattern_size.y
        )
#end valid_grid_pos

def find_open_direction(pos) :
    "finds a random free direction that the wire can start from."
    check_directions = list(range(8))
    random.shuffle(check_directions)
    while True :
        if len(check_directions) == 0 :
            result = 0 # ?
            break
        #end if
        index = check_directions.pop()
        new_pos = pos + directions[index]
        if valid_grid_pos(new_pos) and grid[new_pos].available :
            result = index
            break
        #end if
    #end while
    return \
        result
#end find_open_direction

def no_crossover(dirindex, pos) :
    "checks that a wire extending into pos will not come too close to another wire."
    if dirindex % 2 == 0 :
        # diagonal step
        adj = directions[dirindex]
        result = grid[pos.x - adj.x, pos.y].available or grid[pos.x, pos.y - adj.y].available
    else :
        result = True
    #end if
    return \
        result
#end no_crossover

class Wire :

    def __init__(self, start) :
        self.cells = [start]
        start.available = False
        self.last_direction = find_open_direction(start.pos)
    #end __init__

    def __len__(self) :
        "the length of the wire, in cells."
        return \
            len(self.cells)
    #end __len__

    def render(self, ctx) :
        "draws the Wire into a graphics context."
        ctx.save()
        ctx.source_colour = colours["trace"]
        ctx.line_width = cell_size / 4
        ctx.new_path()
        for cell in self.cells :
            ctx.line_to(cell.pos * cell_size)
        #end for
        ctx.stroke()
        ctx.line_width = cell_size / 6
        for cell in (self.cells[0], self.cells[-1]) :
            ctx.new_path()
            ctx.source_colour = colours["trace"]
            ctx.circle(cell.pos * cell_size, cell_size * 0.35)
            ctx.fill()
            ctx.circle(cell.pos * cell_size, cell_size * 0.21)
            ctx.source_colour = colours["pad"]
            ctx.fill()
        #end for
        ctx.restore()
    #end render

    def generate(self) :
        "actually generates the rest of the wire."
        while True :
            # try extending the wire by another cell, if I can
            if len(self.cells) == wire_length :
                break
            prev_cell = self.cells[-1]
            tries = random.choice(([0, 1, -1], [0, -1, 1]))
            has_space = False
            while True :
                # try another direction from tries, if there are any left
                if len(tries) == 0 :
                    break
                mod = tries.pop(math.floor(random.random() ** straightness * len(tries)))
                index = (self.last_direction + mod) % 8
                direction = directions[index]
                pos = prev_cell.pos + direction
                if valid_grid_pos(pos) :
                    cell = grid[pos]
                    if cell.available and no_crossover(index, pos) :
                        self.cells.append(cell)
                        cell.available = False
                        has_space = True
                        self.last_direction = index
                        break
                    #end if
                #end if
            #end while
            if not has_space :
                break
        #end while
    #end generate

#end Wire

#+
# Mainline
#-

ranseed = None
outfilename = None
opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["cell=", "margin=", "min-wire=", "pattern=", "seed=", "straight=", "wire="]
  )
for keyword, value in opts :
    if keyword == "--cell" :
        cell_size = pos_int(value)
    elif keyword == "--min-wire" :
        min_wire_length = pos_int(value)
    elif keyword == "--margin" :
        margin = vector_str(value, float)
    elif keyword == "--pattern" :
        pattern_size = vector_str(value, pos_int)
    elif keyword == "--seed" :
        ranseed = int(value)
    elif keyword == "--straight" :
        straightness = pos_int(value)
    elif keyword == "--wire" :
        wire_length = pos_int(value)
    #end if
#end for
if len(args) != 0 :
    if len(args) == 1 :
        outfilename = args[0]
    else :
        raise getopt.GetoptError("no more than 1 arg (outfilename) expected")
    #end if
#end if

if ranseed != None :
    random.seed(ranseed)
#end if

grid = Grid()
wires = []
positions_avail = list \
  (
    grid[j, i].pos
    for j in range(pattern_size.x)
    for i in range(pattern_size.y)
  )
while len(positions_avail) != 0 :
    pos = random.choice(positions_avail)
    cell = grid[pos]
    wire = Wire(cell)
    wire.generate()
    wires.append(wire)
    for cell in wire.cells :
        positions_avail.remove(cell.pos)
    #end for
#end while

pix = qah.ImageSurface.create \
  (
    format = CAIRO.FORMAT_RGB24,
    dimensions = round((pattern_size * cell_size + 2 * margin) * dpi / qah.base_dpi)
  )
ctx = \
    (qah.Context.create(pix)
        .scale(dpi / qah.base_dpi)
        .translate(Vector(1, 1) * cell_size / 2)
        .translate(margin)
    )
ctx.source_colour = colours["background"]
ctx.paint()
for wire in wires :
    if len(wire) >= min_wire_length :
        wire.render(ctx)
    #end if
#end for

pix.flush()
if outfilename != None :
    if os.path.isfile(outfilename) :
        raise RuntimeError("already exists: %s" % repr(outfilename))
    #end if
    pix.write_to_png(outfilename)
else :
    proc_display = subprocess.Popen \
      (
        args = ("display", "/dev/stdin"),
        stdin = subprocess.PIPE
      )
    pix.write_to_png_file(proc_display.stdin)
    proc_display.stdin.close()
    proc_display.wait()
#end if
